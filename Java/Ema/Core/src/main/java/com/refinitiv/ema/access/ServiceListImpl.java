///*|-----------------------------------------------------------------------------
// *|            This source code is provided under the Apache 2.0 license      --
// *|  and is provided AS IS with no warranty or guarantee of fit for purpose.  --
// *|                See the project's LICENSE.md for details.                  --
// *|              Copyright (C) 2024 LSEG. All rights reserved.                --
///*|-----------------------------------------------------------------------------

package com.refinitiv.ema.access;

import java.util.ArrayDeque;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;

import com.refinitiv.eta.codec.CodecFactory;
import com.refinitiv.eta.codec.CopyMsgFlags;
import com.refinitiv.eta.codec.MsgClasses;
import com.refinitiv.eta.codec.RequestMsg;

class ServiceListImpl implements ServiceList {

	private String _name; /* name of this service list */
	private List<String> _concreteServiceList;
	private StringBuilder _strBuilder;
	private int _serviceId =  -1; /* This service Id is generated by EMA from ConsumerSession */
	
	private HashSet<String> _concreteServiceHashSet; /* Provides search by using service name */
	
	private ArrayDeque<SingleItem<OmmConsumerClient>> _pendingItemQueue; // This is used to recover items when the concrete service is available.
	
	private LongObject tmpLongObject = new LongObject();
	
	ServiceListImpl(String name)
	{
		_name = name;
		
		_concreteServiceList = new LinkedList<String>();
	}
	
	/* This constructor is used internally to perform deep copy of the specified ServiceList */
	ServiceListImpl(ServiceListImpl serviceList)
	{
		_name = serviceList.name();
		_serviceId = serviceList.serviceId(); 
		
		_concreteServiceList = new LinkedList<String>();
		
		_concreteServiceList.addAll(serviceList.concreteServiceList());
		
		_concreteServiceHashSet = new HashSet<String>(serviceList.concreteServiceList());
		
		_concreteServiceHashSet.addAll(serviceList.concreteServiceList());
		
		_pendingItemQueue = new ArrayDeque<SingleItem<OmmConsumerClient>>();
	}
	
	@Override
	public String name() {
		return _name;
	}
	
	@Override
	public void name(String name) {
		_name = name;
	}

	@Override
	public List<String> concreteServiceList() {
		return _concreteServiceList;
	}

	public int serviceId() {
		return _serviceId;
	}

	public void serviceId(int _serviceId) {
		this._serviceId = _serviceId;
	}

	@Override
	public void clear() {
		_concreteServiceList.clear();
		_name = "";
	}
	
	@Override
	public String toString()
	{
		if(_strBuilder == null)
		{
			_strBuilder = new StringBuilder();
		}
		else
		{
			_strBuilder.setLength(0);
		}
		
		_strBuilder.append("Service list name: " + _name);
		
		if(_serviceId != -1)
			_strBuilder.append("\nService list Id: " + _serviceId);
		
		_strBuilder.append("\nConcrete service names:");
		
		for(String name : _concreteServiceList)
		{
			_strBuilder.append("\n\t" + name);
		}
		
		return _strBuilder.toString();
	}
	
	public int pendingQueueSize()
	{
		return _pendingItemQueue.size();
	}
	
	public void addPendingRequest(SingleItem<OmmConsumerClient> singleItem, ReqMsg reqMsg) 
	{
		singleItem.state(SingleItem.ItemStates.RECOVERING);
		
		singleItem._requestMsg = (RequestMsg)CodecFactory.createMsg();
		
		singleItem._requestMsg.msgClass(MsgClasses.REQUEST);
		((ReqMsgImpl)reqMsg).rsslMsg().copy(singleItem._requestMsg, CopyMsgFlags.ALL_FLAGS);
		
		singleItem._serviceList = this;
		
		_pendingItemQueue.addLast(singleItem);
	}
	
	public void handlePendingRequests(SessionDirectory<OmmConsumerClient> sessionDirectory) 
	{
		/* Checks whether the passed in SessionDirectory belongs to this ServiceList */
		if(!_concreteServiceHashSet.contains(sessionDirectory.serviceName()))
			return;
		
		int count = _pendingItemQueue.size();
		SingleItem<OmmConsumerClient> singleItem = _pendingItemQueue.poll();
		Directory<OmmConsumerClient> directory;
		
		ConsumerSession<OmmConsumerClient> consumerSession = sessionDirectory.consumerSession();
		
		while(singleItem != null)
		{
			tmpLongObject.value(singleItem.itemId());
			
			/* Handles this item when it hasn't been removed from the item map */
			if(consumerSession.watchlist().itemHandleMap().containsKey(tmpLongObject))
			{
				directory = sessionDirectory.directory(singleItem._requestMsg);
				
				if(directory != null)
				{
					singleItem._directory = directory;
					singleItem._serviceName = sessionDirectory.serviceName();
			
					/* The item state is changed to normal item stream */
					singleItem.state(SingleItem.ItemStates.NORMAL);
					singleItem.rsslSubmit(singleItem._requestMsg, false);
					
					if(!singleItem._itemName.isEmpty())
						sessionDirectory.putDirectoryByItemName(singleItem._itemName, singleItem);
				}
				else
				{
					_pendingItemQueue.add(singleItem);
				}
			}
			
			if ( (--count) == 0)
			{
				break;
			}
			
			singleItem = _pendingItemQueue.poll();
		}
	}
	
	public void close(ConsumerSession<OmmConsumerClient> consumerSession)
	{
		/* Send item closed status from pending item queue */
		SingleItem<OmmConsumerClient> singleItem = _pendingItemQueue.poll();
		
		while(singleItem != null && singleItem._requestMsg != null)
		{
			tmpLongObject.value(singleItem.itemId());
			
			/* Handles this item when it hasn't been removed from the item map */
			if(consumerSession.watchlist().itemHandleMap().containsKey(tmpLongObject))
			{
				consumerSession.watchlist().sendItemStatus(singleItem, singleItem._requestMsg, OmmState.StreamState.CLOSED,
						OmmState.DataState.SUSPECT, OmmState.StatusCode.NONE, "Consumer session is closed.");
			}
			
			singleItem = _pendingItemQueue.poll();
		}
	}
}
