package com.reuters.proxy.authentication;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.security.NoSuchAlgorithmException;
import java.security.PrivilegedActionException;
import java.util.ArrayList;

import javax.security.auth.Subject;
import javax.security.auth.callback.Callback;
import javax.security.auth.callback.CallbackHandler;
import javax.security.auth.callback.NameCallback;
import javax.security.auth.callback.PasswordCallback;
import javax.security.auth.login.Configuration;
import javax.security.auth.login.LoginContext;

import com.sun.org.apache.xerces.internal.impl.dv.util.Base64;

public class NegotiateKerberosAuthenticationScheme implements IAuthenticationScheme
{
	private final IProxyAuthenticator _proxyAuthenticator;
	private static final String[] RequiredCredentials = {
		CredentialName.DOMAIN, CredentialName .USERNAME,
		CredentialName.PASSWORD, CredentialName.KRB5_CONFIG_FILE };
//Example krb5 config file:
//		[libdefaults]
//			default_realm = AMERS.IME.REUTERS.COM
//			default_tkt_enctypes = aes128-cts rc4-hmac des3-cbc-sha1 des-cbc-md5 des-cbc-crc
//			default_tgs_enctypes = aes128-cts rc4-hmac des3-cbc-sha1 des-cbc-md5 des-cbc-crc
//			permitted_enctypes   = aes128-cts rc4-hmac des3-cbc-sha1 des-cbc-md5 des-cbc-crc
//
//		[realms]
//			AMERS.IME.REUTERS.COM  = {
//				kdc = oakdamers1.amers.ime.reuters.com 
//				default_domain = AMERS.IME.REUTERS.COM 
//		}
//
//		[domain_realm]
//			.AMERS.IME.REUTERS.COM = AMERS.IME.REUTERS.COM

	private static final String PROXY_AUTHORIZATION_PREFIX = "Proxy-Authorization: ";
	private static final String AUTHORIZATION_PREFIX = "Authorization: ";
	private static final String NEGOTIATEKERBEROS_RESPONSE_PREFIX = "NEGOTIATE ";
	private static final String EOL = "\r\n";
	
	private byte[] serviceTicket;

	protected NegotiateKerberosAuthenticationScheme(IProxyAuthenticator proxyAuthenticator)
	throws NullPointerException
	{
		if (proxyAuthenticator == null)
		{
			throw new NullPointerException(String.format(
					"%s: a valid proxyAuthenticator is required.", this
							.getClass().getName()));
		}

		_proxyAuthenticator = proxyAuthenticator;
	}
	
	@Override
	public IProxyAuthenticator getProxyAuthenicator()
	{
		return _proxyAuthenticator;
	}

	/**
	 * Processes a response from the proxy server and returns a (http)
	 * "Proxy-authorization: " value (e.g. "NEGOTIATE dfdfakajas...") with a
	 * trailing \r\n or an empty string if a "Proxy-authorization: " value does
	 * not need to be sent back to the proxy
	 * 
	 * @param httpResponseCode
	 *            the http response code to handle (e.g. 407)
	 * @param proxyServerResponse
	 *            a response from the proxy server to process (may be null)
	 * @return returns a (http) "Proxy-authorization: " value (e.g.
	 *         "NEGOTIATE TlRMTVNTUA...") with a trailing \r\n or an empty string if
	 *         a "Proxy-authorization: " value does not need to be sent back to
	 *         the proxy
	 * 
	 * @throws ProxyAuthenticationException
	 *             an exception that halted the authentication process occurred
	 */
	@Override
	public String processResponse(int httpResponseCode, String proxyServerResponse)
	throws ProxyAuthenticationException
	{
System.out.println("KERBEROS  NegotiateKerberosAuthenticationScheme::processResponse(int httpResponseCode, String proxyServerResponse)   start");
		StringBuilder proxyAuthorizationValue = new StringBuilder();
		
//		validateCredentials(); // throws an exception if invalid

//		try
//		{
//			HelloKDCandGSSAPI();
//		}
//		catch(Exception e)
//		{
//			throw new ProxyAuthenticationException(e.toString());
//		}
		String credentials = Base64.encode(serviceTicket);

		
		if(httpResponseCode == 407)
		{
			proxyAuthorizationValue.append(PROXY_AUTHORIZATION_PREFIX);
		}
		else
		{
			proxyAuthorizationValue.append(AUTHORIZATION_PREFIX);
		}
		
		proxyAuthorizationValue.append(NEGOTIATEKERBEROS_RESPONSE_PREFIX);
		proxyAuthorizationValue.append(credentials);
		proxyAuthorizationValue.append(EOL);
		return proxyAuthorizationValue.toString();
	}
	
	/**
	 * Throws a ProxyAuthenticationException if the credentials required for
	 * Negotiate/Kerberos authentication are invalid
	 * 
	 * @throws ProxyAuthenticationException
	 */
	@Override
	public void validateCredentials() throws ProxyAuthenticationException
	{
		for(String credentialName : RequiredCredentials)
		{
			if(!_proxyAuthenticator.getCredentials().isSet(credentialName))
			{
				StringBuilder sb = new StringBuilder();
				sb.append(this.getClass().getName());
				sb.append(": The \"");
				sb.append(credentialName);
				sb.append("\" credential is required for Negotiate/Kerberos authentication. ( The full list of required credentials is: ");

				for(String required : RequiredCredentials)
				{
					sb.append(required);
					sb.append(" ");
				}

				sb.append(")");

				throw new ProxyAuthenticationException(sb.toString());
			}
		}
		
		//do HelloKDC and GSSAPI upfront here
		try
		{
			HelloKDCandGSSAPI();
		}
		catch(Exception e)
		{
			throw new ProxyAuthenticationException("Error while attempting to get Kerberos service ticket:  " + e.toString());
		}
	}

	//use JAAS for doing Authentication Server (AS) exchange, i.e. get the Ticket Granting Ticket (TGT)
    //and use GSSAPI for doing Ticket-Granting Server (TGS) exchange, i.e get Kerberos service ticket
	//(AS and TGS are usually in the Key Distribution Center (KDC))
	private void HelloKDCandGSSAPI() throws Exception
	{
     	// domain (pre-authentication) account
        final String domain = _proxyAuthenticator.getCredentials().get(CredentialName.DOMAIN);

        // userName (pre-authentication) account
        final String userName = _proxyAuthenticator.getCredentials().get(CredentialName.USERNAME);

        // Password for the pre-auth acct.
        final String password = _proxyAuthenticator.getCredentials().get(CredentialName.PASSWORD);
        
        // Name of krb5 config file (contains the domain and the kdc)
        final String krbfile = _proxyAuthenticator.getCredentials().get(CredentialName.KRB5_CONFIG_FILE);
        
        // Name of JAAS login config file (has LoginModule of LoginContext to be used)
        String JAASloginConfigFile = getJAASConfigFile();// get the JAAS login config file (from local file system or from jar)
        if(JAASloginConfigFile == null)
        	System.err.println("failed loading JAAS login config file login.conf");
        
        // Name of login module (name of LoginContext in JAAS login config file)
        final String module = "rfaj-kerberos-client";
 
        // set necessary system properties
        System.setProperty("java.security.krb5.conf", krbfile);
        System.setProperty("java.security.auth.login.config", JAASloginConfigFile);
        //System.setProperty("sun.security.krb5.debug", true);
        //System.setProperty("javax.security.auth.useSubjectCredsOnly", "false");

        // assert 
        krb5Validate(userName, password, krbfile, JAASloginConfigFile, module);
 
        final CallbackHandler handler = getUsernamePasswordHandler(userName, password);
 
        final LoginContext loginContext = new LoginContext(module, handler);
        
        // attempt to login, i.e. perform Kerberos Authentication Server (AS) exchange
        loginContext.login();
        //we now have the TGT, which we can get from the authenticated Subject loginContext.subject(),
        //i.e.credentials are populated into Subject
        System.out.println("Kerberos Authentication Server (AS) exchange completed\n");

        // now get Kerberos service ticket for service 'HTTP' from Ticket-Granting Server
      	// (the Kerberos service ticket is an array of encrypted bytes)
       	serviceTicket = getKerberosServiceTicket(userName, domain, "HTTP", _proxyAuthenticator.getProxyHost(), loginContext);
       	if(serviceTicket != null)
       	{
       		System.out.println("serviceTicket size == " + serviceTicket.length);
       		//System.out.println("serviceTicket (hex) ==");
       		//printHex(serviceTicket);
       	}
        if(serviceTicket == null)
        	System.err.println("failed getting serviceTicket");

        // logout
        loginContext.logout();
 
        if(serviceTicket != null)
        	System.out.println("Kerberos Ticket-Granting Server (TGS) exchange completed\n");
	}

	
	private String getJAASConfigFile()
	{
		//Try the local file system first.
		//If not exist, then try from the Jar file (should be rfa.jar).
		String JAASconfigFile = "login.conf";
        File f = new File(JAASconfigFile);
        if(!f.exists())
        {
        	//System.out.println("Trying ClassLoader for resource  com/reuters/proxy/authentication/kerberos/login.conf in rfa.jar");
        	ClassLoader loader = this.getClass().getClassLoader();
        	InputStream fileStream = loader.getResourceAsStream("com/reuters/proxy/authentication/kerberos/login.conf");
        	
        	if(fileStream == null)
        		return null;
        	
        	String line;
        	ArrayList<String> list = new ArrayList<String>();
        	BufferedReader br = null;
        	try
        	{
        		br = new BufferedReader(new InputStreamReader(fileStream));
        		
        		System.out.println("\nJAAS login configuration file used:");
        		while(null != (line = br.readLine()))
        		{
        			list.add(line);
        			System.out.println(line);
        			list.add("\n");
        		}
        		System.out.println();
        	}
        	catch(Exception e)
        	{
        		e.printStackTrace();
        	}
        	finally
        	{
        		try
        		{
        			if(br != null)
        				br.close();
        			if(fileStream != null)
        				fileStream.close();
        		}
        		catch(IOException e)
        		{
        			e.printStackTrace();
        		}
        	}
        	
        	try
        	{
        		//create JAASconfigFile text file
        		FileWriter writer = new FileWriter(JAASconfigFile);
        		for(String str: list)
        		{
        			writer.write(str);
        		}
        		writer.close();
        	}
        	catch(IOException e)
        	{
        		e.printStackTrace();
        	}
        }
        
        return JAASconfigFile;
	}
	
	
    private static void krb5Validate(final String username, final String password,
    		final String krbfile, final String loginfile, final String moduleName) 
    throws FileNotFoundException, NoSuchAlgorithmException
	{
         // confirm username was provided
        if(null == username || username.isEmpty())
		{
            throw new IllegalArgumentException("Must provide a username");
        }
 
        // confirm password was provided
        if(null == password || password.isEmpty())
		{
            throw new IllegalArgumentException("Must provide a password");
        }
 
        // confirm krb5.conf file exists
        if(null == krbfile || krbfile.isEmpty())
		{
            throw new IllegalArgumentException("Must provide a krb5 file");
        }
		else
		{
            final File file = new File(krbfile);
            if(!file.exists())
			{
                throw new FileNotFoundException(krbfile);
            }
        }
 
        // confirm loginfile (JAAS login config file)
        if(null == loginfile || loginfile.isEmpty())
		{
            throw new IllegalArgumentException("Must provide a JAAS login config file");
        }
		else
		{
            final File file = new File(loginfile);
            if(!file.exists())
			{
                throw new FileNotFoundException(loginfile);
            }
        }
 
        // confirm that runtime loaded the login file
        final Configuration config = Configuration.getConfiguration();
 
        // confirm that the module name exists in the file
        if(null == config.getAppConfigurationEntry(moduleName))
		{
            throw new IllegalArgumentException("The module name " 
                    + moduleName + " was not found in the login file");
        }        
    }
    
    private static CallbackHandler getUsernamePasswordHandler(final String username, final String password)
    {
    	final CallbackHandler handler = new CallbackHandler()
    	{
    		public void handle(final Callback[] callback)
    		{
    			for(int i=0; i<callback.length; i++)
    			{
    				if(callback[i] instanceof NameCallback)
    				{
    					final NameCallback nameCallback = (NameCallback) callback[i];
                        nameCallback.setName(username);
                    }
    				else if(callback[i] instanceof PasswordCallback)
    				{
    					final PasswordCallback passCallback = (PasswordCallback) callback[i];
                        passCallback.setPassword(password.toCharArray());
                    }
    				else
    					System.err.println("Unsupported Callback: " + callback[i].getClass().getName());
               }
    		}
    	};
     
        return handler;
    }

    private static byte[] getKerberosServiceTicket(String userName, String domain, String service, String server, LoginContext loginContext)
    throws PrivilegedActionException
    {
    	//
    	// 1st: get TGT (Ticket Granting Ticket)
    	Subject subject = loginContext.getSubject();   //TGT (Ticket Granting Ticket)
    	// output TGT info
    	//System.out.println("\nTicket Granting Ticket ==" + subject);

    	//
    	// 2nd: get Kerberos service ticket, i.e. perform Kerberos Ticket-Granting Server (TGS) exchange
    	byte[] serviceTicket = null;
   		Object doAs = Subject.doAs(subject, new ServiceTicketGenerator("SPNEGO", userName, domain, service, server));
   		serviceTicket = (byte[])doAs;  //Subject.doAs returns the Kerberos service ticket as an array of encrypted bytes
    	
    	return serviceTicket;
    }
    
    public static void printHex(byte[] data)
    {
        int i = 0, j = 0, k = 0;   // loop counters
        int line_addr = 0;  // memory address printed on the left
        String line_to_print = "";

        if(data.length == 0)
        	return;

        StringBuilder _sbbuffer = new StringBuilder();

        // loop through every input byte
        String _hexLine = "";
        String _asciiLine = "";
        for(i = 0, line_addr = 0; i < data.length; i++, line_addr++, k++)
        {
            // print the line numbers at the beginning of the line
            if((i % 16) == 0)
            {
                if(i != 0)
                {
                	k = 0;
                    _sbbuffer.append(_hexLine);
                    //_sbbuffer.append("\t...\t");
                    _sbbuffer.append(" ");
                    _sbbuffer.append(_asciiLine + "\n");
                }

                _asciiLine = "";
                //_hexLine = String.format("%#06x:  ", line_addr);
                _hexLine = String.format("%04X: ", line_addr);
            }

            //_hexLine = _hexLine.concat(String.format("%#04x ", data[i]));
            _hexLine = _hexLine.concat(String.format("%02X ", data[i]));
            if(k==7)
            	_hexLine = _hexLine.concat("  ");

            if(data[i] > 31 && data[i] < 127)
            	_asciiLine = _asciiLine.concat(String.valueOf((char) data[i]));
            else
            	_asciiLine = _asciiLine.concat(".");
        }

        // handle the ASCII for the final line, which may not be completely filled.
        if(i % 16 > 0)
        {
            for(j = 0; j < 16 - (i % 16); j++)
            {
                _hexLine = _hexLine.concat("     ");
            }

            _sbbuffer.append(_hexLine);
            _sbbuffer.append("  ");
            _sbbuffer.append(_asciiLine);
        }

        System.out.println(_sbbuffer.toString());
    }


}
