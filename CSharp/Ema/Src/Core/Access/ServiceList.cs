/*|-----------------------------------------------------------------------------
 *|            This source code is provided under the Apache 2.0 license      --
 *|  and is provided AS IS with no warranty or guarantee of fit for purpose.  --
 *|                See the project's LICENSE.md for details.                  --
 *|              Copyright (C) 2025 LSEG. All rights reserved.                --
 *|-----------------------------------------------------------------------------
 */

using LSEG.Eta.Codec;
using NLog.LayoutRenderers;
using System.Collections.Generic;
using System.Text;

namespace LSEG.Ema.Access
{
    /// <summary>
    /// This class defines a virtual service list name in order to send item requests and fail over to a list of concrete services.
    /// This class is configured in <see cref="OmmConsumerConfig"/> for initializing an <see cref="OmmConsumer"/>.
    /// </summary>
    public sealed class ServiceList
    {
        /// <summary>
        /// Create an instance of ServiceList.
        /// </summary>
        /// <param name="name">specifies a virtual service list name</param>
        public ServiceList(string name)
        {
            Name = name;
        }

        /// <summary>
        /// Gets or sets the name of this service list
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// Gets a list of concrete services.
        /// </summary>
        public List<string> ConcreteServiceList { get; private set; } = new List<string>();

        /// <summary>
        /// Clears the ServiceList and sets all the defaults.
        /// </summary>
        public void Clear()
        {
            Name = string.Empty;
            ConcreteServiceList.Clear();
        }

        /// <summary>
        /// Provides string representation of the current instance
        /// </summary>
        /// <returns>A string that represents this object.</returns>
        public override string ToString()
        {
            m_StrBuilder ??= new StringBuilder();
            m_StrBuilder.Clear();

            m_StrBuilder.AppendLine($"Service list name: {Name}");
            m_StrBuilder.Append("Concrete service names:");
            foreach(var service in ConcreteServiceList)
            {
                m_StrBuilder.AppendLine().Append($"\t{service}");
            }

            return m_StrBuilder.ToString();
        }

        #region Implementation details
        private StringBuilder? m_StrBuilder;
        private HashSet<string>? m_ConcreteServiceHashSet; /* Provides search by using service name */
        private Queue<SingleItem<IOmmConsumerClient>>? m_PendingItemQueue; // This is used to recover items when the concrete service is available.

        internal int ServiceId { get; set; } = -1;  /* This service Id is generated by EMA from ConsumerSession */

        /* This constructor is used internally to perform deep copy of the specified ServiceList */
        internal ServiceList(ServiceList serviceList)
        {
            Name = serviceList.Name;
            ServiceId = serviceList.ServiceId;
            ConcreteServiceList.AddRange(serviceList.ConcreteServiceList);
            m_ConcreteServiceHashSet = new HashSet<string>(serviceList.ConcreteServiceList);
            m_PendingItemQueue = new Queue<SingleItem<IOmmConsumerClient>>();
        }

        internal int PendingQueueSize()
        {
            return m_PendingItemQueue!.Count;
        }

        internal void AddPendingRequest(SingleItem<IOmmConsumerClient> singleItem, RequestMsg reqMsg)
        {
            singleItem.State = SingleItem<IOmmConsumerClient>.StateEnum.RECOVERING;

            singleItem.RequestMsg = new Eta.Codec.Msg();
            singleItem.RequestMsg.MsgClass = MsgClasses.REQUEST;
            reqMsg.m_rsslMsg.Copy(singleItem.RequestMsg, CopyMsgFlags.ALL_FLAGS);

            singleItem.ServiceList = this;

            m_PendingItemQueue!.Enqueue(singleItem);
        }

        internal void HandlePendingRequests(SessionDirectory<IOmmConsumerClient> sessionDirectory)
        {
            /* Checks whether the passed in SessionDirectory belongs to this ServiceList */
            if (!m_ConcreteServiceHashSet!.Contains(sessionDirectory.ServiceName))
                return;

            int count = m_PendingItemQueue!.Count;
            SingleItem<IOmmConsumerClient>? singleItem = m_PendingItemQueue.Count > 0 ? m_PendingItemQueue.Dequeue() : null;
            ServiceDirectory<IOmmConsumerClient>? directory;

            ConsumerSession<IOmmConsumerClient> consumerSession = sessionDirectory.ConsumerSession();

            while (singleItem != null)
            {
                /* Handles this item when it hasn't been removed from the item map */
                if (consumerSession.SessionWatchlist.ItemHandleMap().ContainsKey(singleItem.ItemId))
                {
                    directory = sessionDirectory.Directory(singleItem.RequestMsg);

                    if (directory != null)
                    {
                        singleItem.Directory(directory);
                        singleItem.ServiceName = sessionDirectory.ServiceName;

                        /* The item state is changed to normal item stream */
                        singleItem.State = SingleItem<IOmmConsumerClient>.StateEnum.NORMAL;
                        singleItem.Submit(singleItem.RequestMsg!, singleItem.ServiceName, false, false);

                        if (!string.IsNullOrEmpty(singleItem.ItemName))
                            sessionDirectory.PutDirectoryByItemName(singleItem.ItemName, singleItem);
                    }
                    else
                    {
                        m_PendingItemQueue.Enqueue(singleItem);
                    }
                }

                if ((--count) == 0)
                {
                    break;
                }

                singleItem = m_PendingItemQueue.Dequeue();
            }
        }

        internal void Close(ConsumerSession<IOmmConsumerClient> consumerSession)
        {
            /* Send item closed status from pending item queue */
            SingleItem<IOmmConsumerClient>? singleItem = m_PendingItemQueue!.Count > 0 ? m_PendingItemQueue.Dequeue() : null;

            while (singleItem != null && singleItem.RequestMsg != null)
            {
                /* Handles this item when it hasn't been removed from the item map */
                if (consumerSession.SessionWatchlist.ItemHandleMap().ContainsKey(singleItem.ItemId))
                {
                    consumerSession.SessionWatchlist.SendItemStatus(singleItem, singleItem.RequestMsg, OmmState.StreamStates.CLOSED,
                            OmmState.DataStates.SUSPECT, OmmState.StatusCodes.NONE, "Consumer session is closed.");
                }

                if (m_PendingItemQueue.Count == 0)
                    break;

                singleItem = m_PendingItemQueue.Dequeue();
            }
        }

        #endregion
    }
}
